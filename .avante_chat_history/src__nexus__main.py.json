[{"provider": "claude", "timestamp": "2024-10-25 15:36:56", "model": "claude-3-5-sonnet-20240620", "response": "To convert the main function to use match and case statements, we need to replace the series of if-elif statements with a match-case structure. This change will make the code more readable and potentially more efficient. Here's the suggested modification:\n\nReplace lines: 532-830\n```python\n        command = args[0]\n        state = load_state(config)\n\n        match command:\n            case \"service\":\n                nexus_service(config)\n\n            case \"stop\":\n                try:\n                    subprocess.run([\"screen\", \"-S\", \"nexus\", \"-X\", \"quit\"], check=True)\n                    print(colored(\"Nexus service stopped\", \"green\"))\n                    log_service_event(config, \"Nexus service stopped\")\n                except subprocess.CalledProcessError:\n                    print(colored(\"Failed to stop service\", \"red\"))\n\n            case \"restart\":\n                try:\n                    subprocess.run([\"screen\", \"-S\", \"nexus\", \"-X\", \"quit\"], check=True)\n                    time.sleep(1)\n                    start_service(config)\n                except subprocess.CalledProcessError:\n                    print(colored(\"Failed to restart service\", \"red\"))\n\n            case \"add\":\n                if len(args) < 2:\n                    print(colored('Usage: nexus add \"command\"', \"red\"))\n                    return\n                command_str = \" \".join(args[1:])\n                job = create_job(command_str, config)\n\n                print(\n                    f\"{colored('Added job', 'green')} {colored(job.id, 'magenta', attrs=['bold'])}\"\n                )\n                print(\n                    f\"{colored('Command', 'white', attrs=['bold'])}: {colored(job.command, 'cyan')}\"\n                )\n                print(\n                    f\"{colored('Time Added', 'white', attrs=['bold'])}: {colored(dt.datetime.fromtimestamp(job.created_at), 'cyan')}\"\n                )\n                print(colored(\"The job has been added to the queue.\", \"green\"))\n\n                log_service_event(config, f\"Job {job.id} added to queue: {job.command}\")\n                state.jobs.append(job)\n                save_state(state, config)\n\n            case \"queue\":\n                queued_jobs = [j for j in state.jobs if j.status == JobStatus.QUEUED]\n                print(colored(\"Pending Jobs:\", \"blue\", attrs=[\"bold\"]))\n                for pos, job in enumerate(queued_jobs, 1):\n                    print(\n                        f\"{colored(str(pos), 'blue')}. {colored(job.id, 'magenta')} - {colored(job.command, 'white')}\"\n                    )\n\n            case \"history\":\n                completed_jobs = [\n                    j\n                    for j in state.jobs\n                    if j.status in (JobStatus.COMPLETED, JobStatus.FAILED)\n                ]\n                completed_jobs.sort(key=lambda x: x.completed_at or 0, reverse=True)\n\n                print(colored(\"Completed Jobs:\", \"blue\", attrs=[\"bold\"]))\n                for job in completed_jobs:\n                    runtime = (job.completed_at or 0) - (job.started_at or 0)\n                    status_color = \"red\" if job.status == JobStatus.FAILED else \"green\"\n                    status_text = colored(job.status.name, status_color)\n                    gpu_str = str(job.gpu_index) if job.gpu_index is not None else \"Unknown\"\n\n                    print(\n                        f\"{colored(job.id, 'magenta')}: {colored(job.command, 'white')} \"\n                        f\"(Status: {status_text}, \"\n                        f\"Runtime: {colored(humanize.naturaldelta(runtime), 'cyan')}, \"\n                        f\"GPU: {colored(gpu_str, 'yellow')})\"\n                    )\n                    if job.error_message:\n                        print(f\"  Error: {colored(job.error_message, 'red')}\")\n\n            case \"kill\":\n                if len(args) < 2:\n                    print(colored(\"Usage: nexus kill <id|gpu>\", \"red\"))\n                    return\n\n                target = args[1]\n                killed = False\n\n                try:\n                    # Try as GPU index\n                    gpu_index = int(target)\n                    for job in state.jobs:\n                        if job.status == JobStatus.RUNNING and job.gpu_index == gpu_index:\n                            assert job.screen_session is not None\n                            attach_screen_session(job.screen_session)\n                            job.status = JobStatus.FAILED\n                            job.completed_at = time.time()\n                            job.error_message = \"Killed by user\"\n                            print(\n                                f\"{colored('Killed job', 'green')} {colored(job.id, 'magenta')} \"\n                                f\"{colored(f'on GPU {gpu_index}', 'yellow')}\"\n                            )\n                            killed = True\n                            break\n                except ValueError:\n                    # Try as job ID\n                    for job in state.jobs:\n                        if job.id == target and job.screen_session:\n                            subprocess.run(\n                                [\"screen\", \"-S\", job.screen_session, \"-X\", \"quit\"],\n                                check=True,\n                            )\n                            job.status = JobStatus.FAILED\n                            job.completed_at = time.time()\n                            job.error_message = \"Killed by user\"\n                            print(\n                                f\"{colored('Killed job', 'green')} {colored(job.id, 'magenta')}\"\n                            )\n                            killed = True\n                            break\n\n                if not killed:\n                    print(colored(f\"No running job found with ID or GPU: {target}\", \"red\"))\n                else:\n                    save_state(state, config)\n\n            case \"remove\":\n                if len(args) < 2:\n                    print(colored(\"Usage: nexus remove <id>\", \"red\"))\n                    return\n\n                job_id = args[1]\n                original_len = len(state.jobs)\n                state.jobs = [\n                    j\n                    for j in state.jobs\n                    if not (j.id == job_id and j.status == JobStatus.QUEUED)\n                ]\n\n                if len(state.jobs) != original_len:\n                    print(f\"{colored('Removed job', 'green')} {colored(job_id, 'magenta')}\")\n                    save_state(state, config)\n                else:\n                    print(colored(f\"No queued job found with ID: {job_id}\", \"red\"))\n\n            case \"pause\":\n                state.is_paused = True\n                save_state(state, config)\n                print(colored(\"Queue processing paused\", \"yellow\"))\n\n            case \"resume\":\n                state.is_paused = False\n                save_state(state, config)\n                print(colored(\"Queue processing resumed\", \"green\"))\n\n            case \"logs\":\n                if len(args) < 2:\n                    print(colored(\"Usage: nexus logs <id|service>\", \"red\"))\n                    return\n\n                if args[1] == \"service\":\n                    log_path = config.log_dir / \"service.log\"\n                    if log_path.exists():\n                        print(log_path.read_text())\n                    else:\n                        print(colored(\"No service log found.\", \"red\"))\n                else:\n                    job = next((j for j in state.jobs if j.id == args[1]), None)\n                    if job and job.log_dir:\n                        print(colored(\"=== STDOUT ===\", \"blue\", attrs=[\"bold\"]))\n                        stdout_path = job.log_dir / \"stdout.log\"\n                        if stdout_path.exists():\n                            print(stdout_path.read_text())\n\n                        print(f\"\\n{colored('=== STDERR ===', 'red', attrs=['bold'])}\")\n                        stderr_path = job.log_dir / \"stderr.log\"\n                        if stderr_path.exists():\n                            print(stderr_path.read_text())\n                    else:\n                        print(colored(f\"No logs found for job {args[1]}\", \"red\"))\n\n            case \"attach\":\n                if len(args) < 2:\n                    print(colored(\"Usage: nexus attach <id|gpu|service>\", \"red\"))\n                    return\n\n                target = args[1]\n                session_name = \"nexus\"\n\n                if target == \"service\":\n                    dummy_job = Job(\n                        \"\",\n                        \"\",\n                        JobStatus.RUNNING,\n                        0,\n                        None,\n                        None,\n                        None,\n                        session_name,\n                        [],\n                        None,\n                        None,\n                        None,\n                    )\n                    if is_job_alive(dummy_job):\n                        subprocess.run([\"screen\", \"-r\", session_name])\n                    else:\n                        print(colored(\"No running nexus service found.\", \"red\"))\n                else:\n                    try:\n                        gpu_index = int(target)\n                        running_job = next(\n                            (\n                                j\n                                for j in state.jobs\n                                if j.status == JobStatus.RUNNING\n                                and j.gpu_index == gpu_index\n                            ),\n                            None,\n                        )\n                        if running_job and running_job.screen_session:\n                            subprocess.run([\"screen\", \"-r\", running_job.screen_session])\n                        else:\n                            print(\n                                colored(f\"No running job found on GPU {gpu_index}\", \"red\")\n                            )\n                    except ValueError:\n                        # Try as job ID\n                        job = next(\n                            (\n                                j\n                                for j in state.jobs\n                                if j.id == target and j.status == JobStatus.RUNNING\n                            ),\n                            None,\n                        )\n                        if job and job.screen_session:\n                            subprocess.run([\"screen\", \"-r\", job.screen_session])\n                        else:\n                            print(colored(f\"No running job found with ID: {target}\", \"red\"))\n\n            case \"blacklist\":\n                if len(args) > 1:\n                    subcommand = args[1]\n                    if subcommand == \"add\":\n                        if len(args) < 3:\n                            print(\n                                colored(\"Usage: nexus blacklist add <idx[,idx...]>\", \"red\")\n                            )\n                            return\n                        indices = [int(x) for x in args[2].split(\",\")]\n                        state.blacklisted_gpus.extend(indices)\n                        state.blacklisted_gpus = list(set(state.blacklisted_gpus))  # dedupe\n                        save_state(state, config)\n                        print(colored(f\"Added GPUs to blacklist: {indices}\", \"green\"))\n\n                    elif subcommand == \"remove\":\n                        if len(args) < 3:\n                            print(\n                                colored(\n                                    \"Usage: nexus blacklist remove <idx[,idx...]>\", \"red\"\n                                )\n                            )\n                            return\n                        indices = [int(x) for x in args[2].split(\",\")]\n                        state.blacklisted_gpus = [\n                            x for x in state.blacklisted_gpus if x not in indices\n                        ]\n                        save_state(state, config)\n                        print(colored(f\"Removed GPUs from blacklist: {indices}\", \"green\"))\n                    else:\n                        print(colored(f\"Unknown blacklist subcommand: {subcommand}\", \"red\"))\n                else:\n                    if state.blacklisted_gpus:\n                        print(colored(\"Blacklisted GPUs:\", \"blue\", attrs=[\"bold\"]))\n                        gpus = get_gpu_info(config, state)\n                        for idx in state.blacklisted_gpus:\n                            gpu = next((g for g in gpus if g.index == idx), None)\n                            if gpu:\n                                print(f\"GPU {colored(str(idx), 'yellow')}: {gpu.name}\")\n                    else:\n                        print(colored(\"No GPUs are blacklisted\", \"green\"))\n\n            case \"config\":\n                if len(args) > 1 and args[1] == \"edit\":\n                    editor = os.environ.get(\"EDITOR\", \"vim\")\n                    config_path = pathlib.Path.home() / \".nexus/config.toml\"\n                    subprocess.run([editor, str(config_path)])\n                else:\n                    config_path = pathlib.Path.home() / \".nexus/config.toml\"\n                    print(\n                        f\"{colored('Current configuration', 'blue', attrs=['bold'])}:\\n{config_path.read_text()}\"\n                    )\n\n            case \"help\":\n                if len(args) > 1:\n                    print_command_help(args[1])\n                else:\n                    print_help()\n\n            case _:\n                print(colored(f\"Unknown command: {command}\", \"red\"))\n                print_help()\n```\n\nThis modification replaces the if-elif chain with a match-case structure, which is more readable and potentially more efficient. The functionality remains the same, but the code structure is improved.", "request": "convert to match and case"}]